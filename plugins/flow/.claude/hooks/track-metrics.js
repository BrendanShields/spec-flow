#!/usr/bin/env node

/**
 * Code Metrics Tracking Hook
 * Tracks AI-generated vs human-modified code metrics
 */

const fs = require('fs');
const path = require('path');
const crypto = require('crypto');
const { execSync } = require('child_process');

const METRICS_FILE = '.flow/.metrics.json';
const METRICS_HISTORY_DIR = '.flow/metrics-history';

// Patterns to identify AI-generated code
const AI_SIGNATURES = {
  flow: [
    'Generated by Flow',
    'flow:implement',
    'flow:specify',
    'AI-generated',
    'Auto-generated by'
  ],
  claude: [
    'Claude Code',
    'Generated with Claude',
    'Claude generated this'
  ],
  comments: [
    'TODO: AI-generated - review needed',
    'GENERATED: Do not edit manually'
  ]
};

// Track different types of modifications
const MODIFICATION_TYPES = {
  AI_CREATED: 'ai_created',
  AI_MODIFIED: 'ai_modified',
  HUMAN_CREATED: 'human_created',
  HUMAN_MODIFIED: 'human_modified',
  MIXED: 'mixed'
};

/**
 * Main function to track metrics
 */
async function trackMetrics(context) {
  const metricsPath = path.join(process.cwd(), METRICS_FILE);
  const historyDir = path.join(process.cwd(), METRICS_HISTORY_DIR);

  // Ensure directories exist
  ensureDirectoryExists(path.dirname(metricsPath));
  ensureDirectoryExists(historyDir);

  // Load or initialize metrics
  let metrics = loadMetrics(metricsPath);

  // Determine the operation type
  const operation = detectOperation(context);

  if (operation) {
    // Update metrics based on operation
    updateMetrics(metrics, operation, context);

    // Calculate statistics
    metrics.statistics = calculateStatistics(metrics);

    // Save metrics
    saveMetrics(metricsPath, metrics);

    // Save historical snapshot
    saveHistoricalSnapshot(historyDir, metrics);

    // Generate summary if significant changes
    if (shouldGenerateSummary(operation)) {
      generateMetricsSummary(metrics);
    }
  }
}

/**
 * Detect the type of operation from context
 */
function detectOperation(context) {
  const { tool, command, output, file_path } = context;

  // Determine if this is AI or human operation
  const isAIOperation = detectAIOperation(context);

  if (!file_path) return null;

  const operation = {
    timestamp: new Date().toISOString(),
    file: file_path,
    type: null,
    lines: 0,
    tool: tool,
    skill: extractSkillName(command),
    hash: null
  };

  // Detect operation type
  if (tool === 'Write') {
    operation.type = isAIOperation ?
      MODIFICATION_TYPES.AI_CREATED :
      MODIFICATION_TYPES.HUMAN_CREATED;
    operation.lines = countLines(extractContent(output));
    operation.hash = hashContent(extractContent(output));
  } else if (tool === 'Edit') {
    operation.type = isAIOperation ?
      MODIFICATION_TYPES.AI_MODIFIED :
      MODIFICATION_TYPES.HUMAN_MODIFIED;
    operation.lines = estimateEditedLines(output);
    operation.hash = hashContent(file_path);
  }

  return operation;
}

/**
 * Detect if operation is AI-generated
 */
function detectAIOperation(context) {
  const { command, tool, source } = context;

  // Check if from a Flow skill
  if (command && command.startsWith('flow:')) {
    return true;
  }

  // Check if from Claude
  if (source === 'claude' || source === 'assistant') {
    return true;
  }

  // Check if from a known AI agent
  if (context.agent && context.agent.includes('flow-')) {
    return true;
  }

  // Default to human if unclear
  return false;
}

/**
 * Update metrics with new operation
 */
function updateMetrics(metrics, operation, context) {
  // Initialize file metrics if needed
  if (!metrics.files[operation.file]) {
    metrics.files[operation.file] = {
      created: operation.timestamp,
      lastModified: operation.timestamp,
      aiLines: 0,
      humanLines: 0,
      totalLines: 0,
      modifications: [],
      type: operation.type
    };
  }

  const fileMetrics = metrics.files[operation.file];

  // Update line counts
  if (operation.type === MODIFICATION_TYPES.AI_CREATED) {
    fileMetrics.aiLines += operation.lines;
    metrics.totals.aiGeneratedLines += operation.lines;
    metrics.totals.aiGeneratedFiles++;
  } else if (operation.type === MODIFICATION_TYPES.AI_MODIFIED) {
    fileMetrics.aiLines += operation.lines;
    metrics.totals.aiModifiedLines += operation.lines;
  } else if (operation.type === MODIFICATION_TYPES.HUMAN_CREATED) {
    fileMetrics.humanLines += operation.lines;
    metrics.totals.humanWrittenLines += operation.lines;
    metrics.totals.humanCreatedFiles++;
  } else if (operation.type === MODIFICATION_TYPES.HUMAN_MODIFIED) {
    fileMetrics.humanLines += operation.lines;
    metrics.totals.humanModifiedLines += operation.lines;
  }

  // Track modification
  fileMetrics.modifications.push({
    timestamp: operation.timestamp,
    type: operation.type,
    lines: operation.lines,
    tool: operation.tool,
    skill: operation.skill
  });

  // Update file totals
  fileMetrics.totalLines = fileMetrics.aiLines + fileMetrics.humanLines;
  fileMetrics.lastModified = operation.timestamp;

  // Update global totals
  metrics.totals.totalOperations++;
  metrics.lastUpdated = operation.timestamp;

  // Track skills usage
  if (operation.skill) {
    metrics.skills[operation.skill] = (metrics.skills[operation.skill] || 0) + 1;
  }

  // Track hourly activity
  const hour = new Date(operation.timestamp).getHours();
  metrics.hourlyActivity[hour] = (metrics.hourlyActivity[hour] || 0) + 1;
}

/**
 * Calculate statistics from metrics
 */
function calculateStatistics(metrics) {
  const stats = {
    aiPercentage: 0,
    humanPercentage: 0,
    totalLines: 0,
    totalFiles: Object.keys(metrics.files).length,
    averageLinesPerFile: 0,
    mostActiveHour: 0,
    topSkills: [],
    fileTypeDistribution: {},
    generationVelocity: 0
  };

  // Calculate total lines
  stats.totalLines = metrics.totals.aiGeneratedLines +
                     metrics.totals.aiModifiedLines +
                     metrics.totals.humanWrittenLines +
                     metrics.totals.humanModifiedLines;

  // Calculate percentages
  if (stats.totalLines > 0) {
    const aiLines = metrics.totals.aiGeneratedLines + metrics.totals.aiModifiedLines;
    const humanLines = metrics.totals.humanWrittenLines + metrics.totals.humanModifiedLines;

    stats.aiPercentage = Math.round((aiLines / stats.totalLines) * 100);
    stats.humanPercentage = Math.round((humanLines / stats.totalLines) * 100);
  }

  // Average lines per file
  if (stats.totalFiles > 0) {
    stats.averageLinesPerFile = Math.round(stats.totalLines / stats.totalFiles);
  }

  // Find most active hour
  let maxActivity = 0;
  for (const [hour, count] of Object.entries(metrics.hourlyActivity)) {
    if (count > maxActivity) {
      maxActivity = count;
      stats.mostActiveHour = parseInt(hour);
    }
  }

  // Top skills
  stats.topSkills = Object.entries(metrics.skills)
    .sort((a, b) => b[1] - a[1])
    .slice(0, 5)
    .map(([skill, count]) => ({ skill, count }));

  // File type distribution
  for (const file of Object.keys(metrics.files)) {
    const ext = path.extname(file) || 'no-extension';
    stats.fileTypeDistribution[ext] = (stats.fileTypeDistribution[ext] || 0) + 1;
  }

  // Generation velocity (lines per hour over last 24h)
  const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
  let recentLines = 0;
  for (const file of Object.values(metrics.files)) {
    for (const mod of file.modifications) {
      if (new Date(mod.timestamp) > oneDayAgo) {
        recentLines += mod.lines;
      }
    }
  }
  stats.generationVelocity = Math.round(recentLines / 24);

  return stats;
}

/**
 * Load existing metrics
 */
function loadMetrics(metricsPath) {
  if (fs.existsSync(metricsPath)) {
    try {
      return JSON.parse(fs.readFileSync(metricsPath, 'utf8'));
    } catch (error) {
      console.error('Error loading metrics:', error);
    }
  }

  // Initialize new metrics
  return {
    version: '1.0.0',
    created: new Date().toISOString(),
    lastUpdated: new Date().toISOString(),
    totals: {
      aiGeneratedFiles: 0,
      aiGeneratedLines: 0,
      aiModifiedLines: 0,
      humanCreatedFiles: 0,
      humanWrittenLines: 0,
      humanModifiedLines: 0,
      totalOperations: 0
    },
    files: {},
    skills: {},
    hourlyActivity: {},
    statistics: {}
  };
}

/**
 * Save metrics
 */
function saveMetrics(metricsPath, metrics) {
  fs.writeFileSync(metricsPath, JSON.stringify(metrics, null, 2));
}

/**
 * Save historical snapshot
 */
function saveHistoricalSnapshot(historyDir, metrics) {
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const snapshotPath = path.join(historyDir, `metrics-${timestamp}.json`);

  // Save snapshot every hour
  const files = fs.readdirSync(historyDir);
  const oneHourAgo = Date.now() - 60 * 60 * 1000;
  const recentSnapshot = files.find(f => {
    const stat = fs.statSync(path.join(historyDir, f));
    return stat.mtime.getTime() > oneHourAgo;
  });

  if (!recentSnapshot) {
    fs.writeFileSync(snapshotPath, JSON.stringify(metrics, null, 2));

    // Keep only last 30 days of snapshots
    cleanOldSnapshots(historyDir, 30);
  }
}

/**
 * Generate metrics summary
 */
function generateMetricsSummary(metrics) {
  const { statistics } = metrics;

  const summary = {
    type: 'metrics-update',
    message: `ðŸ“Š Code Generation Metrics Update`,
    details: {
      'AI Generated': `${statistics.aiPercentage}% (${formatNumber(metrics.totals.aiGeneratedLines)} lines)`,
      'Human Written': `${statistics.humanPercentage}% (${formatNumber(metrics.totals.humanWrittenLines)} lines)`,
      'Total Files': statistics.totalFiles,
      'Generation Rate': `${statistics.generationVelocity} lines/hour`,
      'Top Skill': statistics.topSkills[0]?.skill || 'None'
    }
  };

  // Output summary
  console.log(JSON.stringify(summary, null, 2));

  // Also create a dashboard file
  createMetricsDashboard(metrics);
}

/**
 * Create metrics dashboard
 */
function createMetricsDashboard(metrics) {
  const dashboardPath = path.join(process.cwd(), '.flow', 'metrics-dashboard.md');
  const { statistics, totals } = metrics;

  const dashboard = `# Code Generation Metrics Dashboard

## Summary
- **Last Updated**: ${new Date(metrics.lastUpdated).toLocaleString()}
- **Project Started**: ${new Date(metrics.created).toLocaleString()}

## Code Distribution
\`\`\`
AI Generated:    ${createBar(statistics.aiPercentage)} ${statistics.aiPercentage}%
Human Written:   ${createBar(statistics.humanPercentage)} ${statistics.humanPercentage}%
\`\`\`

## Statistics
| Metric | Value |
|--------|-------|
| Total Lines | ${formatNumber(statistics.totalLines)} |
| Total Files | ${statistics.totalFiles} |
| AI Generated Files | ${totals.aiGeneratedFiles} |
| Human Created Files | ${totals.humanCreatedFiles} |
| Average Lines/File | ${statistics.averageLinesPerFile} |
| Generation Velocity | ${statistics.generationVelocity} lines/hour |

## Top Skills Used
${statistics.topSkills.map((s, i) =>
  `${i + 1}. **${s.skill}**: ${s.count} operations`
).join('\n')}

## File Type Distribution
${Object.entries(statistics.fileTypeDistribution)
  .sort((a, b) => b[1] - a[1])
  .map(([ext, count]) => `- **${ext}**: ${count} files`)
  .join('\n')}

## Activity Pattern
Most Active Hour: **${statistics.mostActiveHour}:00**

## Trends
- AI assistance is ${statistics.aiPercentage > 50 ? 'primary' : 'supplementary'} (${statistics.aiPercentage}%)
- Average generation rate: ${statistics.generationVelocity} lines/hour
- Most used skill: ${statistics.topSkills[0]?.skill || 'None'}

---
*Generated by Flow Metrics Tracking System*
`;

  fs.writeFileSync(dashboardPath, dashboard);
}

// Helper functions

function ensureDirectoryExists(dir) {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
}

function countLines(content) {
  if (!content) return 0;
  return content.split('\n').length;
}

function estimateEditedLines(output) {
  // Rough estimate based on output
  const matches = output.match(/\d+\s+(lines?|additions?|deletions?)/gi);
  if (matches) {
    const numbers = matches.map(m => parseInt(m.match(/\d+/)[0]));
    return Math.max(...numbers);
  }
  return 10; // Default estimate
}

function hashContent(content) {
  if (!content) return null;
  return crypto.createHash('md5').update(content).digest('hex');
}

function extractContent(output) {
  // Extract content from tool output
  const contentMatch = output.match(/```[\s\S]*?```/);
  return contentMatch ? contentMatch[0] : output;
}

function extractSkillName(command) {
  if (!command) return null;
  const match = command.match(/^(flow:\w+)/);
  return match ? match[1] : null;
}

function shouldGenerateSummary(operation) {
  // Generate summary for significant operations
  return operation.type === MODIFICATION_TYPES.AI_CREATED ||
         (operation.lines && operation.lines > 50);
}

function formatNumber(num) {
  return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
}

function createBar(percentage) {
  const filled = Math.round(percentage / 5);
  const empty = 20 - filled;
  return 'â–ˆ'.repeat(filled) + 'â–‘'.repeat(empty);
}

function cleanOldSnapshots(dir, daysToKeep) {
  const cutoff = Date.now() - (daysToKeep * 24 * 60 * 60 * 1000);
  const files = fs.readdirSync(dir);

  files.forEach(file => {
    const filePath = path.join(dir, file);
    const stat = fs.statSync(filePath);
    if (stat.mtime.getTime() < cutoff) {
      fs.unlinkSync(filePath);
    }
  });
}

// Main execution
async function main() {
  try {
    const input = JSON.parse(fs.readFileSync(0, 'utf8'));
    await trackMetrics(input);
    process.exit(0);
  } catch (error) {
    console.error(JSON.stringify({
      type: 'metrics-error',
      message: error.message
    }));
    process.exit(0); // Don't block on errors
  }
}

main();