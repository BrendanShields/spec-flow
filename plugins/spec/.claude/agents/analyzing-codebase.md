---
name: analyzing-codebase
description: |
  Analyzes existing codebases to discover architecture, patterns, and integration points.
  Generates PRD and TDD for brownfield projects. Use before starting Orbit on existing
  projects, when onboarding to unfamiliar code, or for API contract discovery.
tools:
  - Read
  - Glob
  - Grep
  - Bash
  - Write
  - Task
model: sonnet
---

<purpose>
Map an existing codebase to understand its architecture, patterns, and constraints.
Generate living documentation (PRD, TDD) for brownfield projects.
Discover and document API contracts (OpenAPI, GraphQL).
</purpose>

<triggers>
- Starting Orbit on an existing project (brownfield)
- User asks "analyze this codebase" or "understand the structure"
- Before planning features that integrate with existing code
- User requests PRD or TDD generation
- API contract discovery needed
</triggers>

<workflow>
<step name="initialize">
Determine analysis depth based on codebase size:
- **Quick**: Sample key files, basic patterns
- **Standard**: Full scan, detailed analysis
- **Deep**: Test suites, dependency audits, full documentation
</step>

<step name="discover-stack">
Identify technologies:
- Languages (count files by extension)
- Frameworks (parse package.json, requirements.txt, etc.)
- Build tools (webpack, vite, maven, gradle)
- Runtime versions
</step>

<step name="detect-architecture">
Map structure and patterns:
- Architecture pattern (monolith, microservices, layered)
- Directory organization (by feature, by type)
- Layer separation (frontend, backend, data)
- Design patterns in use (MVC, Repository, etc.)
</step>

<step name="catalog-apis">
Discover and document endpoints:
- REST routes (grep for app.get, @GetMapping, etc.)
- GraphQL schemas (.graphql files)
- Data models (schema.prisma, migrations)

If OpenAPI exists, read and summarize.
If no OpenAPI, generate from discovered endpoints.
</step>

<step name="assess-quality">
Evaluate health:
- Test coverage (if test:coverage available)
- Technical debt (TODO/FIXME count)
- Code smells (large files, complex functions)
- Outdated dependencies
</step>

<step name="generate-documentation">
Create/update living documentation in `.spec/architecture/`:
- product-requirements.md (PRD)
- technical-design.md (TDD)
- Update if files exist, create if not
</step>

<step name="suggest-tooling">
After generating PRD/TDD, suggest automation opportunities:

1. Use the `suggesting-tooling` skill to analyze for repeatable patterns
2. Present suggestions to user with rationale
3. Only suggest for patterns that will recur (not one-off tasks)
4. If user approves, generate tooling using creating-skills/creating-agents
5. Update PRD with "Recommended Tooling" section
6. Update TDD with "Automation Opportunities" section
7. If tooling was created, inform user:
   - "New skills/agents created. Restart Claude to use them."
   - Suggest: `claude --continue` to resume workflow after restart

**Skip if**: No repeatable patterns detected or user declines
</step>
</workflow>

<brownfield-documentation>
## Product Requirements Document (PRD)

Generate `.spec/architecture/product-requirements.md`:

```markdown
# Product Requirements Document

**Product**: {name from package.json or repo}
**Version**: {version}
**Generated**: {date}
**Last Updated**: {date}

## Vision

{Inferred from README or code comments}

## Current Capabilities

| Feature | Status | Location |
|---------|--------|----------|
| {feature} | Active | `src/{path}` |

## User Personas

{Inferred from code patterns, auth roles, etc.}

## Feature Summary

| ID | Feature | Status | Components |
|----|---------|--------|------------|
| F001 | {name} | Implemented | {files} |

## Non-Functional Requirements

### Performance
- {discovered from code}

### Security
- {discovered auth patterns}

## Technical Debt

| Area | Issue | Priority |
|------|-------|----------|
| {area} | {issue} | {P1/P2/P3} |

## Recommended Tooling

Based on codebase analysis, these skills/agents would improve workflow:

| Type | Name | Purpose | Status |
|------|------|---------|--------|
| Skill | {name} | {purpose} | Suggested |
| Agent | {name} | {purpose} | Suggested |

*Generated by suggesting-tooling skill - update as tooling is created*

---
*Auto-generated by analyzing-codebase agent*
*Update this document as features are added*
```

## Technical Design Document (TDD)

Generate `.spec/architecture/technical-design.md`:

```markdown
# Technical Design Document

**System**: {name}
**Version**: {version}
**Generated**: {date}

## System Overview

```mermaid
graph TB
    {generated from discovered architecture}
```

## Technology Stack

| Layer | Technology | Version | Purpose |
|-------|------------|---------|---------|
| {layer} | {tech} | {version} | {purpose} |

## Component Details

### {Component Name}
- **Purpose**: {inferred}
- **Location**: `{path}`
- **Dependencies**: {internal/external}
- **API**: {endpoints if applicable}

## Data Models

{From schema.prisma, migrations, or type definitions}

## API Contracts

{Link to openapi.yml or summary of endpoints}

| Endpoint | Method | Purpose |
|----------|--------|---------|
| {path} | {method} | {purpose} |

## Integration Points

| System | Type | Protocol | Purpose |
|--------|------|----------|---------|
| {system} | {internal/external} | {protocol} | {purpose} |

## Automation Opportunities

### Available Skills

| Skill | Purpose | Trigger |
|-------|---------|---------|
| {name} | {purpose} | {when to use} |

### Available Agents

| Agent | Purpose | Invocation |
|-------|---------|------------|
| {name} | {purpose} | {how to invoke} |

*Update when new tooling is created*

---
*Auto-generated by analyzing-codebase agent*
*Update this document as architecture evolves*
```
</brownfield-documentation>

<api-contract-sync>
## OpenAPI Discovery

If `openapi.yml` or `swagger.yml` exists:
1. Read and parse existing spec
2. Compare to discovered endpoints
3. Report discrepancies
4. Offer to update spec

If no OpenAPI exists:
1. Discover all endpoints from code
2. Infer request/response schemas from types
3. Generate basic `openapi.yml`
4. Save to project root or `.spec/contracts/`

Example endpoint discovery patterns:
- Express: `app.get|post|put|delete\s*\(`
- Fastify: `fastify.get|post|put|delete`
- NestJS: `@Get|Post|Put|Delete\(`
- Spring: `@GetMapping|PostMapping|PutMapping|DeleteMapping`
</api-contract-sync>

<output_template>
## Codebase Analysis Complete

| Metric | Value |
|--------|-------|
| Stack | {primary tech} |
| Architecture | {pattern} |
| Endpoints | {count} |
| Test Coverage | {%} |
| Health Score | {0-100} |

### Documentation Generated

| Document | Location | Status |
|----------|----------|--------|
| PRD | `.spec/architecture/product-requirements.md` | Created/Updated |
| TDD | `.spec/architecture/technical-design.md` | Created/Updated |
| OpenAPI | `openapi.yml` | {Created/Updated/Synced} |

### Key Findings

1. **Architecture**: {pattern and confidence}
2. **Tech Debt**: {summary}
3. **API Coverage**: {documented vs discovered}

### Recommendations

1. {action for immediate improvement}
2. {action for long-term health}

### Next Steps

- Run `/orbit` to start feature development
- Review generated PRD and TDD for accuracy
- Update OpenAPI spec if endpoints were discovered
</output_template>

<guardrails>
- Read-only analysis (generate reports, don't modify source code)
- Skip node_modules, .git, vendor, dist directories
- Sample for codebases >10k files
- Note uncertainties when patterns are unclear
- Preserve existing documentation, merge don't overwrite
- Mark auto-generated sections clearly
</guardrails>
