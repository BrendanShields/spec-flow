#!/usr/bin/env node

/**
 * Code Metrics Tracking Hook
 *
 * Tracks and analyzes code metrics to understand AI vs human contributions.
 * This hook monitors file operations and maintains detailed statistics about:
 * - AI-generated code (via Spec skills and Claude)
 * - Human-written code
 * - Modification patterns
 * - Development velocity
 * - Skill usage patterns
 *
 * Metrics are saved to {spec_root}/.metrics.json with historical snapshots in
 * {spec_root}/metrics-history/ for trend analysis.
 */

import * as path from 'path';
import * as crypto from 'crypto';
import { BaseHook } from '../../core/base-hook';
import { resolveSpecRoot } from '../../core/path-resolver';
import {
  ensureDirectory,
  readJSON,
  writeJSON,
  listFiles,
  deleteFile,
  countLines,
} from '../../utils/file-utils';
import {
  HookContext,
  MetricsData,
  Operation,
  ModificationType,
  Statistics,
} from '../../types';

/**
 * Patterns to identify AI-generated code (FIXED: spec not flow)
 * Note: Currently not used but kept for future signature detection feature
 */
// const AI_SIGNATURES = {
//   spec: [
//     'Generated by Spec',
//     'spec:implement',
//     'spec:specify',
//     'spec:generate',
//     'spec:plan',
//     'AI-generated',
//     'Auto-generated by',
//   ],
//   claude: ['Claude Code', 'Generated with Claude', 'Claude generated this'],
//   comments: ['TODO: AI-generated - review needed', 'GENERATED: Do not edit manually'],
// };

/**
 * Track different types of modifications
 */
const MODIFICATION_TYPES = {
  AI_CREATED: 'ai_created' as ModificationType,
  AI_MODIFIED: 'ai_modified' as ModificationType,
  HUMAN_CREATED: 'human_created' as ModificationType,
  HUMAN_MODIFIED: 'human_modified' as ModificationType,
  MIXED: 'mixed' as ModificationType,
};

/**
 * Code Metrics Tracking Hook
 *
 * Analyzes file operations from tool execution context and updates metrics
 * tracking AI vs human contributions, skill usage, and development velocity.
 */
export class TrackMetricsHook extends BaseHook {
  private metricsFile: string;
  private historyDir: string;

  constructor() {
    super('track-metrics');

    // Use config-driven paths (FIXED: no hardcoded .spec/)
    const specRoot = resolveSpecRoot(this.config, this.cwd);
    this.metricsFile = path.join(specRoot, '.metrics.json');
    this.historyDir = path.join(specRoot, 'metrics-history');
  }

  /**
   * Execute the metrics tracking hook
   */
  async execute(context: HookContext): Promise<void> {
    // Ensure directories exist
    ensureDirectory(path.dirname(this.metricsFile));
    ensureDirectory(this.historyDir);

    // Load or initialize metrics
    const metrics = this.loadMetrics();

    // Determine the operation type
    const operation = this.detectOperation(context);

    if (operation) {
      // Update metrics based on operation
      this.updateMetrics(metrics, operation);

      // Calculate statistics
      metrics.statistics = this.calculateStatistics(metrics);

      // Save metrics
      this.saveMetrics(metrics);

      // Save historical snapshot
      this.saveHistoricalSnapshot(metrics);

      // Generate summary if significant changes
      if (this.shouldGenerateSummary(operation)) {
        this.generateMetricsSummary(metrics);
      }
    }
  }

  /**
   * Detects the type of file operation and classifies it
   */
  private detectOperation(context: HookContext): Operation | null {
    const { tool, command, output, file_path } = context;

    // Determine if this is AI or human operation
    const isAIOperation = this.detectAIOperation(context);

    if (!file_path) return null;

    let operationType: ModificationType = MODIFICATION_TYPES.AI_CREATED;

    // Detect operation type
    if (tool === 'Write') {
      operationType = isAIOperation
        ? MODIFICATION_TYPES.AI_CREATED
        : MODIFICATION_TYPES.HUMAN_CREATED;
    } else if (tool === 'Edit') {
      operationType = isAIOperation
        ? MODIFICATION_TYPES.AI_MODIFIED
        : MODIFICATION_TYPES.HUMAN_MODIFIED;
    }

    const operation: Operation = {
      timestamp: new Date().toISOString(),
      file: file_path,
      type: operationType,
      lines: 0,
      tool: tool || 'Unknown',
      skill: this.extractSkillName(command),
      hash: null,
    };

    // Calculate lines and hash
    if (tool === 'Write') {
      operation.lines = countLines(this.extractContent(output || ''));
      operation.hash = this.hashContent(this.extractContent(output || ''));
    } else if (tool === 'Edit') {
      operation.lines = this.estimateEditedLines(output || '');
      operation.hash = this.hashContent(file_path);
    }

    return operation;
  }

  /**
   * Detect if operation is AI-generated (FIXED: spec not flow)
   */
  private detectAIOperation(context: HookContext): boolean {
    const { command, source, agent } = context;

    // Check if from a Spec skill (FIXED: spec: not flow:)
    if (command && command.startsWith('spec:')) {
      return true;
    }

    // Check if from Claude
    if (source === 'claude' || source === 'assistant') {
      return true;
    }

    // Check if from a known AI agent (FIXED: spec- not flow-)
    if (agent && agent.includes('spec-')) {
      return true;
    }

    // Default to human if unclear
    return false;
  }

  /**
   * Update metrics with new operation
   */
  private updateMetrics(metrics: MetricsData, operation: Operation): void {
    // Initialize file metrics if needed
    if (!metrics.files[operation.file]) {
      metrics.files[operation.file] = {
        created: operation.timestamp,
        lastModified: operation.timestamp,
        aiLines: 0,
        humanLines: 0,
        totalLines: 0,
        modifications: [],
        type: operation.type,
      };
    }

    const fileMetrics = metrics.files[operation.file]!; // We just ensured it exists

    // Update line counts
    if (operation.type === MODIFICATION_TYPES.AI_CREATED) {
      fileMetrics.aiLines += operation.lines;
      metrics.totals.aiGeneratedLines += operation.lines;
      metrics.totals.aiGeneratedFiles++;
    } else if (operation.type === MODIFICATION_TYPES.AI_MODIFIED) {
      fileMetrics.aiLines += operation.lines;
      metrics.totals.aiModifiedLines += operation.lines;
    } else if (operation.type === MODIFICATION_TYPES.HUMAN_CREATED) {
      fileMetrics.humanLines += operation.lines;
      metrics.totals.humanWrittenLines += operation.lines;
      metrics.totals.humanCreatedFiles++;
    } else if (operation.type === MODIFICATION_TYPES.HUMAN_MODIFIED) {
      fileMetrics.humanLines += operation.lines;
      metrics.totals.humanModifiedLines += operation.lines;
    }

    // Track modification
    fileMetrics.modifications.push({
      timestamp: operation.timestamp,
      type: operation.type,
      lines: operation.lines,
      tool: operation.tool,
      skill: operation.skill,
    });

    // Update file totals
    fileMetrics.totalLines = fileMetrics.aiLines + fileMetrics.humanLines;
    fileMetrics.lastModified = operation.timestamp;

    // Update global totals
    metrics.totals.totalOperations++;
    metrics.lastUpdated = operation.timestamp;

    // Track skills usage
    if (operation.skill) {
      metrics.skills[operation.skill] = (metrics.skills[operation.skill] || 0) + 1;
    }

    // Track hourly activity
    const hour = new Date(operation.timestamp).getHours();
    metrics.hourlyActivity[hour] = (metrics.hourlyActivity[hour] || 0) + 1;
  }

  /**
   * Calculate statistics from metrics
   */
  private calculateStatistics(metrics: MetricsData): Statistics {
    const stats: Statistics = {
      aiPercentage: 0,
      humanPercentage: 0,
      totalLines: 0,
      totalFiles: Object.keys(metrics.files).length,
      averageLinesPerFile: 0,
      mostActiveHour: 0,
      topSkills: [],
      fileTypeDistribution: {},
      generationVelocity: 0,
    };

    // Calculate total lines
    stats.totalLines =
      metrics.totals.aiGeneratedLines +
      metrics.totals.aiModifiedLines +
      metrics.totals.humanWrittenLines +
      metrics.totals.humanModifiedLines;

    // Calculate percentages
    if (stats.totalLines > 0) {
      const aiLines = metrics.totals.aiGeneratedLines + metrics.totals.aiModifiedLines;
      const humanLines = metrics.totals.humanWrittenLines + metrics.totals.humanModifiedLines;

      stats.aiPercentage = Math.round((aiLines / stats.totalLines) * 100);
      stats.humanPercentage = Math.round((humanLines / stats.totalLines) * 100);
    }

    // Average lines per file
    if (stats.totalFiles > 0) {
      stats.averageLinesPerFile = Math.round(stats.totalLines / stats.totalFiles);
    }

    // Find most active hour
    let maxActivity = 0;
    for (const [hour, count] of Object.entries(metrics.hourlyActivity)) {
      if (count > maxActivity) {
        maxActivity = count;
        stats.mostActiveHour = parseInt(hour);
      }
    }

    // Top skills
    stats.topSkills = Object.entries(metrics.skills)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5)
      .map(([skill, count]) => ({ skill, count }));

    // File type distribution
    for (const file of Object.keys(metrics.files)) {
      const ext = path.extname(file) || 'no-extension';
      stats.fileTypeDistribution[ext] = (stats.fileTypeDistribution[ext] || 0) + 1;
    }

    // Generation velocity (lines per hour over last 24h)
    const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
    let recentLines = 0;
    for (const file of Object.values(metrics.files)) {
      for (const mod of file.modifications) {
        if (new Date(mod.timestamp) > oneDayAgo) {
          recentLines += mod.lines;
        }
      }
    }
    stats.generationVelocity = Math.round(recentLines / 24);

    return stats;
  }

  /**
   * Load existing metrics
   */
  private loadMetrics(): MetricsData {
    try {
      return readJSON<MetricsData>(this.metricsFile);
    } catch (error) {
      // Initialize new metrics if file doesn't exist
      return {
        version: '1.0.0',
        created: new Date().toISOString(),
        lastUpdated: new Date().toISOString(),
        totals: {
          aiGeneratedFiles: 0,
          aiGeneratedLines: 0,
          aiModifiedLines: 0,
          humanCreatedFiles: 0,
          humanWrittenLines: 0,
          humanModifiedLines: 0,
          totalOperations: 0,
        },
        files: {},
        skills: {},
        hourlyActivity: {},
        statistics: {
          aiPercentage: 0,
          humanPercentage: 0,
          totalLines: 0,
          totalFiles: 0,
          averageLinesPerFile: 0,
          mostActiveHour: 0,
          topSkills: [],
          fileTypeDistribution: {},
          generationVelocity: 0,
        },
      };
    }
  }

  /**
   * Save metrics
   */
  private saveMetrics(metrics: MetricsData): void {
    writeJSON(this.metricsFile, metrics);
  }

  /**
   * Save historical snapshot
   */
  private saveHistoricalSnapshot(metrics: MetricsData): void {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const snapshotPath = path.join(this.historyDir, `metrics-${timestamp}.json`);

    // Save snapshot every hour
    const files = listFiles(this.historyDir, { pattern: /\.json$/ });
    const oneHourAgo = Date.now() - 60 * 60 * 1000;
    const recentSnapshot = files.find((f) => {
      try {
        const stat = require('fs').statSync(f);
        return stat.mtime.getTime() > oneHourAgo;
      } catch {
        return false;
      }
    });

    if (!recentSnapshot) {
      writeJSON(snapshotPath, metrics);

      // Keep only last 30 days of snapshots
      this.cleanOldSnapshots(30);
    }
  }

  /**
   * Generate metrics summary
   */
  private generateMetricsSummary(metrics: MetricsData): void {
    const { statistics } = metrics;

    this.logger.custom('metrics-update', 'ðŸ“Š Code Generation Metrics Update', {
      'AI Generated': `${statistics.aiPercentage}% (${this.formatNumber(metrics.totals.aiGeneratedLines)} lines)`,
      'Human Written': `${statistics.humanPercentage}% (${this.formatNumber(metrics.totals.humanWrittenLines)} lines)`,
      'Total Files': statistics.totalFiles,
      'Generation Rate': `${statistics.generationVelocity} lines/hour`,
      'Top Skill': statistics.topSkills[0]?.skill || 'None',
    });

    // Also create a dashboard file
    this.createMetricsDashboard(metrics);
  }

  /**
   * Create metrics dashboard (FIXED: use config path, not .flow/)
   */
  private createMetricsDashboard(metrics: MetricsData): void {
    const specRoot = resolveSpecRoot(this.config, this.cwd);
    const dashboardPath = path.join(specRoot, 'metrics-dashboard.md');
    const { statistics, totals } = metrics;

    const dashboard = `# Code Generation Metrics Dashboard

## Summary
- **Last Updated**: ${new Date(metrics.lastUpdated).toLocaleString()}
- **Project Started**: ${new Date(metrics.created).toLocaleString()}

## Code Distribution
\`\`\`
AI Generated:    ${this.createBar(statistics.aiPercentage)} ${statistics.aiPercentage}%
Human Written:   ${this.createBar(statistics.humanPercentage)} ${statistics.humanPercentage}%
\`\`\`

## Statistics
| Metric | Value |
|--------|-------|
| Total Lines | ${this.formatNumber(statistics.totalLines)} |
| Total Files | ${statistics.totalFiles} |
| AI Generated Files | ${totals.aiGeneratedFiles} |
| Human Created Files | ${totals.humanCreatedFiles} |
| Average Lines/File | ${statistics.averageLinesPerFile} |
| Generation Velocity | ${statistics.generationVelocity} lines/hour |

## Top Skills Used
${statistics.topSkills.map((s, i) => `${i + 1}. **${s.skill}**: ${s.count} operations`).join('\n')}

## File Type Distribution
${Object.entries(statistics.fileTypeDistribution)
  .sort((a, b) => b[1] - a[1])
  .map(([ext, count]) => `- **${ext}**: ${count} files`)
  .join('\n')}

## Activity Pattern
Most Active Hour: **${statistics.mostActiveHour}:00**

## Trends
- AI assistance is ${statistics.aiPercentage > 50 ? 'primary' : 'supplementary'} (${statistics.aiPercentage}%)
- Average generation rate: ${statistics.generationVelocity} lines/hour
- Most used skill: ${statistics.topSkills[0]?.skill || 'None'}

---
*Generated by Spec Metrics Tracking System*
`;

    writeJSON(dashboardPath, dashboard);
  }

  // Helper methods

  private estimateEditedLines(output: string): number {
    // Rough estimate based on output
    const matches = output.match(/\d+\s+(lines?|additions?|deletions?)/gi);
    if (matches) {
      const numbers = matches.map((m) => parseInt(m.match(/\d+/)![0]));
      return Math.max(...numbers);
    }
    return 10; // Default estimate
  }

  private hashContent(content: string): string | null {
    if (!content) return null;
    return crypto.createHash('md5').update(content).digest('hex');
  }

  private extractContent(output: string): string {
    // Extract content from tool output
    const contentMatch = output.match(/```[\s\S]*?```/);
    return contentMatch ? contentMatch[0] : output;
  }

  private extractSkillName(command: string | null | undefined): string | null {
    if (!command) return null;
    // FIXED: Extract spec: commands, not flow:
    const match = command.match(/^(spec:\w+)/);
    return match ? (match[1] ?? null) : null;
  }

  private shouldGenerateSummary(operation: Operation): boolean {
    // Generate summary for significant operations
    return (
      operation.type === MODIFICATION_TYPES.AI_CREATED || operation.lines > 50
    );
  }

  private formatNumber(num: number): string {
    return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
  }

  private createBar(percentage: number): string {
    const filled = Math.round(percentage / 5);
    const empty = 20 - filled;
    return 'â–ˆ'.repeat(filled) + 'â–‘'.repeat(empty);
  }

  private cleanOldSnapshots(daysToKeep: number): void {
    const cutoff = Date.now() - daysToKeep * 24 * 60 * 60 * 1000;
    const files = listFiles(this.historyDir, { pattern: /\.json$/ });

    for (const file of files) {
      try {
        const stat = require('fs').statSync(file);
        if (stat.mtime.getTime() < cutoff) {
          deleteFile(file);
        }
      } catch {
        // Ignore errors
      }
    }
  }
}

// Main execution
async function main(): Promise<void> {
  const hook = new TrackMetricsHook();
  await hook.run();
}

main();
